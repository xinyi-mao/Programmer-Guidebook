动态规划的入门，一般是从斐波拉契数列开始。该数列由0和1开始，后面的每一项数字都是前面两项数字的和，定义如下：

    F(0) = 0,   F(1) = 1
    F(n) = F(n - 1) + F(n - 2), 其中 n > 1

给定一个n，要求F(n)，用递归方法可以很容易地解决这个问题，代码如下：
```python
def fib(self, n: int) -> int:
    if n == 0 or n == 1:
        return n
    return fib(n-1) + fib(n-2)
```

然而，上面的递归方法会造成大量重复计算，因为有很多重复子问题，时间复杂度为O(2^n)。例如，在求f(5)时，需要先求子问题f(4)和f(3)。递归地求f(4)时，又要先求子问题f(3)和f(2)，这里的f(3)与求f(5)时的子问题就重复了。

为了解决这个问题，我们就想到一个方法：如果我们每次都把结果保存下来,复杂度就会大大降低。能不能让每个重复的子问题都只计算一次，即每个F(n)都只计算一次。这就是动态规划的核心思想：

1. 将原问题分解成一系列子问题
2. 每个子问题只求解一次，保存到一个状态数组`dp[]`中

用动态规划来解斐波拉契数列：
```python
def fib(self, n: int) -> int:
    if n == 0 or n == 1:
        return n
    dp = [0] * (n+1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n+1):    
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```
将时间复杂度由O(2^n)降低到了O(n)，真香！

***

如果看了上面的内容，你还是云里雾里，那么：

**很正常**

理解了dp的思想，也不一定会刷题，下面分享一套自己的刷题模板。首先来看一个经典的爬楼梯问题：
